---
title: "Untitled"
author: "Jonathan Bourne"
date: "1 August 2017"
output: html_document
---

#Setup Chunk

```{r}
setwd("/home/jonno/Create_ETYS_network/SubCode")
source("Setup.R")

```


#Load Tariff and Trasnport
 
```{r}
KeepPath <- getwd()

#Load Tariff aka generation data
setwd(Tariff)

GenerationData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =10, skip = 33) %>%
  setNames(make.names(names(.))) %>%
  mutate(Site = str_sub(Node.1,1,4))

LocalAssetData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =11, skip = 11) %>%
  setNames(make.names(names(.)))

TransportData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =12, skip = 11) %>%
  setNames(make.names(names(.)))

setwd(KeepPath)
rm(KeepPath)
```

#Clean and seperate Transport

```{r}
trans1 <-TransportData[,1:16] %>% 
  filter(!is.na(Bus.ID))

trans2 <- TransportData[,17:59] %>% 
  filter(!is.na(Bus.1)) %>%
  group_by(Bus.1, Bus.2) %>% #trying to stop the non-unique identifier problem
    mutate(Link = paste(Bus.1,Bus.2, 1:n(),sep = "-")) %>% #This allows multiple edges 
    #between the same node pair, it is not certain the data is always correct!
    ungroup  %>%
#set construct line limits really high
  mutate(Link.Type = tolower(Link.Type),
    Link.Limit = ifelse(Link.Type == "construct", 1e5, Link.Limit))
  
```



```{r}

NodeGraph <-trans2 %>%
  mutate(Node1 = Bus.1,
         Node2 = Bus.2) %>%
  select(Node1, Node2) %>%
  as.matrix() %>% 
  graph_from_edgelist(., directed = FALSE)

NodeGraph %>% 
  simplify(., remove.multiple = T, remove.loops = T) %>% 
  plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA)
length(V(SubStatGraph2))

```

#Injection Vector
```{r}
InjectionVector <- trans1 %>% arrange(Bus.Name) %>% .$BusTransferB
```


#Create Impedance and Transmission matrix

parallel susceptances are added together. does this mean that when there are multiple lines connecting two nodes they should be added together and have the total capacity added together or should they be help seperate?

the removing of parallel cables may be causing some of the over capacity lines

```{r}
Impedance <- trans2 %>%
  mutate(Y = 1/X..Peak.Security.) %>%
  select(Bus.1, Bus.2, Y)

```

#Alternative calc

```{r}

#checks that only inlcuded nodes are being counted
ValidNodes <- trans1 %>% 
  filter(Bus.Name %in% c(Impedance$Bus.1, Impedance$Bus.2)) 



#remove Slack bus, usually the largest generator
SlackRef<-which.max(ValidNodes$BusTransferA)

SlackRef<- which(ValidNodes$Bus.Order == 0)

PowerAlt <- PowerFlow(Impedance, ValidNodes, SlackRef)

PowerAlt2 <- PowerAlt%>%
  left_join(., select(trans2, Link, Link.Limit, Link.Type, LineFlow__1 ), by = "Link") %>%
  mutate(Over.Limit = abs(MW)>Link.Limit,
         Over.Limitx1.5 = abs(MW)>(Link.Limit*1.5)) %>%
  mutate(MW = round(MW),
         LineFlow__1= round(LineFlow__1),
         ratio = MW/LineFlow__1,
         diff  = MW-LineFlow__1,
         absdiff = abs(diff))


#corellation is strong enough, I am not going to focus on higher matching atm
cor(PowerAlt2$MW, PowerAlt2$LineFlow__1)

```

#Voltage Matching
Everyone matches to the same voltage unless it is a transformer.
There is an excpetion three types called construct also have different volatges, these could be also transformers under construction... this should be tested.


colours

green<- Transformer
orange <- 132
purple <- 275
Pink <- 400


```{r}

Vmatch <- trans1 %>% select(Bus.Name, Voltage)

Vnet <- trans2 %>% 
  select(Bus.1, Bus.2, Link.Type, Link) %>%
  left_join(., Vmatch, by = c("Bus.1"="Bus.Name")) %>%
  rename(Voltage.1 = Voltage) %>%
  left_join(., Vmatch, by = c("Bus.2"="Bus.Name")) %>%
  rename(Voltage.2 = Voltage) %>%
  mutate(Link.Voltage = as.factor(ifelse(Voltage.1 == Voltage.2, Voltage.1, 0)))

VoltCols <-  with(Vnet,
        data.frame(Link.Voltage = levels(Link.Voltage),
                   color = I(brewer.pal(nlevels(Link.Voltage), name = 'Dark2')))) 

Vnet <-   VoltCols %>%
  left_join(Vnet,.)

Vnet2 <- Vnet %>% filter(Voltage.1 != Voltage.2)

g <- graph.data.frame(Vnet[,1:2], vertices=Vmatch, directed=FALSE) #%>%
 # simplify(., remove.multiple = T, remove.loops = T) 
  
#V(g)$color <- V(g)$Voltage

#plot(g,vertex.size=5, edge.arrow.size=.4, vertex.label = NA)




E(g)$color<-Vnet$color

#Network colouored by voltage

set.seed(1530)
plot(g,vertex.size=1, edge.arrow.size=1, vertex.label = NA, main = "Grid by Link Voltage")


g <- delete_edges(g, (1:nrow(Vnet))[Vnet$Link.Voltage == 0] )

set.seed(1530)
plot(g,vertex.size=1, edge.arrow.size=1, vertex.label = NA, main = "Network of similar voltages")

#OverCapcity using my calcs

g <- graph.data.frame(Vnet[,1:2], vertices=Vmatch, directed=FALSE)
E(g)$color<-ifelse(PowerAlt2$Over.Limit, "red", "blue")

set.seed(1530)
plot(g,vertex.size=1, edge.arrow.size=1, vertex.label = NA, main = "Over Capacity My calc")

#Over Capacity Using grid calcs

E(g)$color<-ifelse(PowerAlt2$Over.Limit, "red", "blue")
set.seed(1530)
plot(g,vertex.size=1, edge.arrow.size=1, vertex.label = NA, main = "Over Capacity My calc")

#Amount of power flow

E(g)$color<- with(PowerAlt2,
        data.frame(levels = 10:1,
                   color = I(brewer.pal(10, name = 'RdYlBu'))))$color[ntile(PowerAlt2$MW, 10)]

set.seed(1530)
plot(g,vertex.size=0.5, edge.arrow.size=10, vertex.label = NA, main = "Mw deciles, Blue=low, Red=High")


```


```{r}
Volt.colours <- data.frame(Link.Voltage = unique(Vnet$Link.Voltage), Vcolour= brewer.pal(4, "Set1"))

g2 <- Vnet %>% 
  select(Bus.1, Bus.2, Link.Voltage) %>%
  left_join(., Volt.colours)
  


set.seed(10052016)
ggplot(data = g2, aes(from_id = Bus.1, to_id = Bus.2)) +
  geom_net( layout.alg = "kamadakawai", 
           size = 2, labelon = FALSE, vjust = -0.6, ecolour = g2$Vcolour,
           directed =FALSE, fontsize = 3, ealpha = 0.5) +
  xlim(c(-0.05, 1.05)) +
  theme_net() +
  theme(legend.position = "bottom")


```



Graph Stats

```{r}

NetworkStats <- function(g, colname = "value"){
data_frame(Metric = c("Nodes", "edges" ,"betweenness", "degree", "assortativity", "clustering", "distance"),
           value = c(vcount(g), ecount(g), mean(betweenness(g)),mean(degree(g)), assortativity(g, degree(g)),
                     transitivity(g), mean(shortest.paths(g)))
) %>% setNames(c("Metric", colname))

}



```



```{r}
gbase <- graph.data.frame(Impedance[,1:2], directed=FALSE)


  AZero <-  Impedance %>%
    CreateTransmission(., "Bus.1", "Bus.2")
  
  # #remove Slack bus, usually the largest generator
  # SlackRef<-which.max(ValidNodes$BusTransferA)

  A <- AZero[,colnames(AZero)!=trans1$Bus.Name[SlackRef]]
  
  #Vreate the diagonal matrix of 
  C <- LinePropertiesMatrix(Impedance, "Bus.1", "Bus.2")
  
  B <- t(A) %*% C %*% A

gImp <- solve(B) %>% graph.adjacency(., mode="undirected", weighted=TRUE)

  gX <- Impedance %>%
  graph.data.frame(., directed=FALSE)
E(gImp)$weight <- 1/Impedance$Y

test <- NetworkStats(gImp, "Impedance")


DiffNetStats <- left_join(NetworkStats(gbase, "Topological"), NetworkStats(gImp, "Impedance"), by= "Metric") %>%
  left_join(., NetworkStats(gX, "Reactance"), by= "Metric") %>%
  mutate_if(.,is.numeric, funs(format(round(.,3), scientific=F)) )

test <- distances(gbase)
test <- distances(gImp, weights = "Y")

```


#geo data

```{r}
setwd(file.path(basewd, "Substations"))


```


Impedance$Xi
as.complex(Impedance$Xi)
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
R = R....on.100MVA.,
X = X....on.100MVA.,
B = B....on.100MVA.,
MVA=Spring.Rating..MVA.) %>%
mutate(ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = -(X*MVA)/((R*MVA)^2+(X*MVA)^2))
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
R = R....on.100MVA.,
X = X....on.100MVA.,
B = B....on.100MVA.,
MVA=Spring.Rating..MVA.) %>%
mutate(ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X) %>% Mod,
ImpInvS2 = 1/(B*MVA),
ImpRX2 = -(X*MVA)/((R*MVA)^2+(X*MVA)^2))
rename(
R = R....on.100MVA.,
X = X....on.100MVA.,
B = B....on.100MVA.,
MVA=Spring.Rating..MVA.) %>%
mutate(ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = -(X*MVA)/((R*MVA)^2+(X*MVA)^2))
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
R = R....on.100MVA.,
X = X....on.100MVA.,
B = B....on.100MVA.,
MVA=Spring.Rating..MVA.) %>%
mutate(ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = -(X*MVA)/((R*MVA)^2+(X*MVA)^2))
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
R = R....on.100MVA.,
X = X....on.100MVA.,
B = B....on.100MVA.,
MVA=Spring.Rating..MVA.) %>%
mutate(ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = complex(real = R, imaginary = X)*MVA)
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
MVA=Spring.Rating..MVA.) %>%
mutate(
R = R....on.100MVA./100,
X = X....on.100MVA./100,
B = B....on.100MVA./100,
ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = complex(real = R, imaginary = X)*MVA)
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
MVA=Spring.Rating..MVA.) %>%
mutate(
R = R....on.100MVA./100,
X = X....on.100MVA./100,
B = B....on.100MVA./100,
ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = complex(real = R, imaginary = X)*MVA,
B2 = X/(R^2+X^2))
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
MVA=Spring.Rating..MVA.) %>%
mutate(
R = R....on.100MVA./100,
X = X....on.100MVA./100,
B = B....on.100MVA./100,
ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = complex(real = R, imaginary = X)*MVA,
B2 = -X/(R^2+X^2))
?Mod
packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr")
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(packages, library, character.only = TRUE)
#Set up file system to read the correct folders this switches between aws and windows mode
datafile<- "/home/jonno/Dropbox/Jonathan Bourne Phd Folder/ETYSAppendixB"
Functions <-"/home/jonno/Create_ETYS_network/Functions"
list.files(Functions) %>% map(~source(file.path(Functions,.x)))
#create the path to the file
path <- file.path(datafile, "ETYS 2016 Appendix B.xlsx")
#Create a list of all the sheets in the file
AllData <- path %>%
excel_sheets(.) %>%
lapply(., read_excel, path = path, skip = 1, trim_ws = TRUE ) %>%
map(~.x %>% setNames(make.names(names(.))))
#break out the sheet names
AllData[[1]] <- AllData[[1]] %>%
setNames(c("Table", "Title")) %>%
filter(complete.cases(.)) %>%
mutate(Table = replace(Table, Table=="Table", "Index"),
element = 1:(n())) #provides list element reference
names(AllData) <- AllData[[1]]$Table
View(AllData$Index)
Substation <- StackList(2:4) %>%
mutate(Site.Code = str_trim(Site.Code),
Site.Name = str_trim(Site.Name))
Circuits <- StackList(6:8)
names(AllData[[16]])[1:2] <-c("Node1", "Node2") #The name had been written differently to the other two
Transformers <- StackList(14:16)
names(AllData[[24]])[4] <-"MVAr.Generation"
names(AllData[[23]])[5] <-"MVAr.Absorbtion"
names(AllData[[24]])[5] <-"MVAr.Absorbtion"
AllData[[22]]$MVAr.Absorption<- AllData[[22]]$MVAr.Absorption %>%gsub("[^A-Z0-9]", "", ., ignore.case = TRUE)
RCE<- AllData[22:24] %>% map(~.x %>% RemoveSymbols %>%
mutate(Unit.Number = as.character(Unit.Number),
Connection.Voltage..kV. = as.character(Connection.Voltage..kV.)))%>%
map2_df(.x =.,
.y = names(.),
~ .x %>%
mutate(Table =.y ) )
AllData[[22]]$MVAr.Generation %>% table
AllData[[23]]$MVAr.Generation %>% table
AllData[[24]]$MVAr.Generation %>% table
View(Circuits)
Impedance <- Circuits[,c(1,2,6:8,10)] %>%
rename(
MVA=Spring.Rating..MVA.) %>%
mutate(
R = R....on.100MVA./100,
X = X....on.100MVA./100,
B = B....on.100MVA./100,
ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = complex(real = R, imaginary = X)*MVA,
B2 = -X/(R^2+X^2))
View(Impedance)
View(Impedance)
?graph_from_edgelist
Impmat <- Impedance[,1:2] %>% graph_from_edgelist(., directed = FALSE)
Impmat <- Impedance[,1:2] %>% as.matrix %>% graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(Impedance$ImpInvS)
plot(Impmat,layout=layout.fruchterman.reingold,edge.width=E(Impmat)$weight/2)
plot(Impmat,edge.width=E(Impmat)$weight/2)
plot(Impmat)
test <- as.matrix(Impmat)
test <- as_adjacency_matrix(Impmat)
test <- as_adjacency_matrix(Impmat) %>% as.matrix
View(test)
?as_adjacency_matrix()
test <- as_adjacency_matrix(Impmat, attr = "weight") %>% as.matrix
View(test)
rowSums(test)
diag(test) <- rowSums(test)
View(test)
Impmat <- Impedance[,1:2] %>%
as.matrix %>%
graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(Impedance$ImpInvS)
Impmat  <- as_adjacency_matrix(Impmat, attr = "weight") %>% as.matrix
diag(Impmat ) <- -rowSums(Impmat )
Impmat  <- -Impmat
View(Impmat)
CreateImpedance <- function(df){
#takes a three column dataframe where the first two columns are the node that the edge will connect to
#The third column is the impedance of the edge.
#Returns an impedance matrix
Impmat <- df[,1:2] %>%
as.matrix %>%
graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(df[,3])
Impmat <- as_adjacency_matrix(Impmat, attr = "weight") %>% as.matrix
diag(Impmat ) <- -rowSums(Impmat )
Impmat  <- -Impmat
return(Impmat)
}
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
test <- Impedance %>% select(Node1,Node2, ImpInvS)
View(test)
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
df <- Impedance
Impmat <- df[,1:2] %>%
as.matrix %>%
graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(df[,3])
as.numeric(df[,3])
df[,3]
as.numeric(df[,3])
as.numeric(unlist(df[,3]))
E(Impmat)$weight <- as.numeric(unlist(df[,3]))
rm(df)
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
CreateImpedance <- function(df){
#takes a three column dataframe where the first two columns are the node that the edge will connect to
#The third column is the impedance of the edge.
#Returns an impedance matrix
Impmat <- df[,1:2] %>%
as.matrix %>%
graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(unlist(df[,3]))
Impmat <- as_adjacency_matrix(Impmat, attr = "weight") %>% as.matrix
diag(Impmat ) <- -rowSums(Impmat )
Impmat  <- -Impmat
return(Impmat)
}
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
View(test)
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance
Impmat<- Impedance %>%
select(Node1,Node2, ImpInvS) %>%
CreateImpedance
rm(test)
Admat<- Impedance %>%
muatet(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
CreateImpedance
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
CreateImpedance
View(Admat)
#Create impedance using X
Impmat<- Impedance %>%
select(Node1,Node2, X*MVA) %>%
CreateImpedance
#Create impedance using X
Impmat2 <- Impedance %>%
mutate(X2 = X*MVA ) %>%
select(Node1,Node2, X*MVA) %>%
CreateImpedance
#Create impedance using X
Impmat2 <- Impedance %>%
mutate(X2 = X*MVA ) %>%
select(Node1,Node2, X2) %>%
CreateImpedance
View(RCE)
View(Impmat2)
packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr")
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(packages, library, character.only = TRUE)
#Set up file system to read the correct folders this switches between aws and windows mode
datafile<- "/home/jonno/Dropbox/Jonathan Bourne Phd Folder/ETYSAppendixB"
Functions <-"/home/jonno/Create_ETYS_network/Functions"
list.files(Functions) %>% map(~source(file.path(Functions,.x)))
```
#Loading and creating a structure for the data
```{r}
#create the path to the file
path <- file.path(datafile, "ETYS 2016 Appendix B.xlsx")
#Create a list of all the sheets in the file
AllData <- path %>%
excel_sheets(.) %>%
lapply(., read_excel, path = path, skip = 1, trim_ws = TRUE ) %>%
map(~.x %>% setNames(make.names(names(.))))
#break out the sheet names
AllData[[1]] <- AllData[[1]] %>%
setNames(c("Table", "Title")) %>%
filter(complete.cases(.)) %>%
mutate(Table = replace(Table, Table=="Table", "Index"),
element = 1:(n())) #provides list element reference
names(AllData) <- AllData[[1]]$Table
View(AllData$Index)
```
#Create base data
```{r}
Substation <- StackList(2:4) %>%
mutate(Site.Code = str_trim(Site.Code),
Site.Name = str_trim(Site.Name)) #remove leading and trailing whitespace which causes problems with analysis.
Circuits <- StackList(6:8)
names(AllData[[16]])[1:2] <-c("Node1", "Node2") #The name had been written differently to the other two
Transformers <- StackList(14:16)
#The RCE needs a lot of treatment as there are formatting differences and also the bind_rows part of map_df doesn't coerce, which is annoying.
names(AllData[[24]])[4] <-"MVAr.Generation"
names(AllData[[23]])[5] <-"MVAr.Absorbtion"
names(AllData[[24]])[5] <-"MVAr.Absorbtion"
AllData[[22]]$MVAr.Absorption<- AllData[[22]]$MVAr.Absorption %>%gsub("[^A-Z0-9]", "", ., ignore.case = TRUE)
RCE<- AllData[22:24] %>% map(~.x %>% RemoveSymbols %>%
mutate(Unit.Number = as.character(Unit.Number),
Connection.Voltage..kV. = as.character(Connection.Voltage..kV.)))%>%
map2_df(.x =.,
.y = names(.),
~ .x %>%
mutate(Table =.y ) )
demand <- read_excel(file.path(datafile,"ETYS16 AppG demand data.xlsx"), skip = 7)
#Percent f demand that matches a nodes
sum(unique(demand$Node) %in% unique(FullnameCounts$Name))/length(unique(demand$Node))
#check using just site this matches loads
sum(str_sub(unique(demand$Node),1,4) %in% str_sub(unique(FullnameCounts$Name),1,4))/length(unique(demand$Node))
demand2 <- FullnameCounts %>% filter(grepl("AMEM", Name))
test <- FullnameCounts %>% filter(Name %in% unique(demand$Node))
demand2 <- demand %>% filter(grepl("BEAU", Node))
Impedance <- bind_rows(mutate(Circuits, MVA=Spring.Rating..MVA.,
Type = "Circuit"),
mutate(Transformers, MVA = Rating..MVA.,
Type = "Transformer")) %>%
select(Node1, Node2, R....on.100MVA., X....on.100MVA., B....on.100MVA.,
MVA, Type) %>%
mutate(
R = R....on.100MVA./100,
X = X....on.100MVA./100,
B = B....on.100MVA./100,
MVA = round(MVA, 0),
ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = complex(real = R, imaginary = X)*MVA,
B2 = -X/(R^2+X^2)) %>%
#create the voltage matching
mutate(Node1b = str_sub(Node1, 1, 4),
Node2b = str_sub(Node2, 1, 4))
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
CreateImpedance
nrow(Admat)
union_all(rownames(Admat))
unique(rownames(Admat))
unique(rownames(Admat)) %>% length
View(CreateImpedance)
View(CreateImpedance)
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2)
View(Admat)
#Create addmitance using 1/X
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
group_by(Node1,Node2) %>%
summarise(B2 = sum(B2)) %>%
CreateImpedance
nrow(Admat)
MinVolt <- Substation %>%
group_by(Site.Code) %>%
summarise(V = min(Voltage..kV.))
Voltagemaker <- left_join(data.frame(Node = colnames(Admat)),
demand, by = "Node") %>%
group_by(Node) %>%
mutate_all(funs(ifelse(is.na(.),0,1)))%>%
ungroup %>%
.[,c(1,3)] %>%
mutate(Site.Code = str_sub(Node, 1,4)) %>%
left_join(., MinVolt, by = "Site.Code") %>%
mutate(V = ifelse(is.na(V),0, V)) #some nodes don't have a site, these are set to 0
test <- CreateTransmission(Impedance, "Node1", "Node2", "B2")
CreateTransmission <- function(df, StartNode, EndNode, edgeweight){
df <- df %>% rename_(Node1 = StartNode,
Node2 = EndNode,
EdgeWeight = edgeweight) %>%
mutate(Edgename = paste(Node1,Node2, sep = "-"))
df2 <- df %>% select(Edgename, Node1, EdgeWeight)
df3 <- df %>% select(Edgename, Node2, EdgeWeight) %>%
mutate(EdgeWeight = -EdgeWeight) %>%
rename(Node1 = Node2)
df <- bind_rows(df2, df3) %>%
spread(., Node1, EdgeWeight, fil = 0)
Transmat <- df
# Transmat <- df[,1:2] %>%
#   as.matrix %>%
#   graph_from_edgelist(., directed = FALSE)
#
# E(Transmat)$weight <- as.numeric(unlist(df[,3]))
#
# Transmat <- as_adjacency_matrix(Transmat, attr = "weight") %>% as.matrix
return(Transmat)
}
test <- CreateTransmission(Impedance, "Node1", "Node2", "B2")
View(Impedance)
CreateTransmission <- function(df, StartNode, EndNode, edgeweight){
df <- df %>% rename_(Node1 = StartNode,
Node2 = EndNode,
EdgeWeight = edgeweight) %>%
group_by(Node1, Node2) %>%
mutate(Edgename = paste(Node1,Node2, 1:n(),sep = "-")) %>% ungroup
df2 <- df %>% select(Edgename, Node1, EdgeWeight)
df3 <- df %>% select(Edgename, Node2, EdgeWeight) %>%
mutate(EdgeWeight = -EdgeWeight) %>%
rename(Node1 = Node2)
df <- bind_rows(df2, df3) %>%
spread(., Node1, EdgeWeight, fil = 0)
Transmat <- df
# Transmat <- df[,1:2] %>%
#   as.matrix %>%
#   graph_from_edgelist(., directed = FALSE)
#
# E(Transmat)$weight <- as.numeric(unlist(df[,3]))
#
# Transmat <- as_adjacency_matrix(Transmat, attr = "weight") %>% as.matrix
return(Transmat)
}
test <- Impedence %>%
CreateTransmission(., "Node1", "Node2", "B2")
test <- Impedance %>%
CreateTransmission(., "Node1", "Node2", "B2")
source('~/Create_ETYS_network/Functions/CreateTransmission.R')
source('~/Create_ETYS_network/Functions/CreateTransmission.R')
CreateTransmission <- function(df, StartNode, EndNode, edgeweight){
df <- df %>% rename_(Node1 = StartNode,
Node2 = EndNode,
EdgeWeight = edgeweight) %>%
#mutate(Edgename = paste(Node1,Node2, sep = "-"))
group_by(Node1, Node2) %>% #trying to stop the non-unique identifier problem
mutate(Edgename = paste(Node1,Node2, 1:n(),sep = "-")) %>% ungroup
df2 <- df %>% select(Edgename, Node1, EdgeWeight)
df3 <- df %>% select(Edgename, Node2, EdgeWeight) %>%
mutate(EdgeWeight = -EdgeWeight) %>%
rename(Node1 = Node2)
df <- bind_rows(df2, df3) %>%
spread(., Node1, EdgeWeight, fil = 0)
Transmat <- df
# Transmat <- df[,1:2] %>%
#   as.matrix %>%
#   graph_from_edgelist(., directed = FALSE)
#
# E(Transmat)$weight <- as.numeric(unlist(df[,3]))
#
# Transmat <- as_adjacency_matrix(Transmat, attr = "weight") %>% as.matrix
return(Transmat)
}
test <- Impedance %>%
CreateTransmission(., "Node1", "Node2", "B2")
Impedance %>% select(Node1, Node2, B2) %>% slice(1976,4385)
Impedance %>% select(Node1, Node2, B2) %>% slice(c(1976,4385))
?slice
Impedance %>% select(Node1, Node2, B2) .[c(1976,4385),]
Impedance %>% select(Node1, Node2, B2) %>% .[c(1976,4385),]
52/76
1-52/76
library(igrpah); ibrary(dplyr)
#generate random graph
set.seed(500)
RandomGraph <- sample_gnm(1000, 2500)
#name nodes
V(RandomGraph)$name <- paste0("Node", 1:1000)
#Get the coordinates of the Nodes
Coords <- layout_with_fr(RandomGraph) %>%
as_tibble %>%
bind_cols(data_frame(names = names(V(RandomGraph))))
#Delete random vertices
deletevertex <-sample( V(RandomGraph)$name, 400)
RandomGraph2 <-delete.vertices(RandomGraph, deletevertex)
#get the coordinates of the remaining Nodes
NetCoords <- data_frame(names = names(V(RandomGraph2))) %>%
left_join(Coords, by= "names")
#plot both graphs
RandomGraph%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(Coords[,1:2]))
RandomGraph2%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(NetCoords[,2:3]))
#They nodes have the same relationship to each other but are not laid out in the same position in the frame
library(igrpah); ibrary(dplyr)
library(igraph); ibrary(dplyr)
#generate random graph
set.seed(500)
RandomGraph <- sample_gnm(1000, 2500)
#name nodes
V(RandomGraph)$name <- paste0("Node", 1:1000)
#Get the coordinates of the Nodes
Coords <- layout_with_fr(RandomGraph) %>%
as_tibble %>%
bind_cols(data_frame(names = names(V(RandomGraph))))
#Delete random vertices
deletevertex <-sample( V(RandomGraph)$name, 400)
RandomGraph2 <-delete.vertices(RandomGraph, deletevertex)
#get the coordinates of the remaining Nodes
NetCoords <- data_frame(names = names(V(RandomGraph2))) %>%
left_join(Coords, by= "names")
#plot both graphs
RandomGraph%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(Coords[,1:2]))
RandomGraph2%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(NetCoords[,2:3]))
#They nodes have the same relationship to each other but are not laid out in the same position in the frame
library(igraph); library(dplyr)
#generate random graph
set.seed(500)
RandomGraph <- sample_gnm(1000, 2500)
#name nodes
V(RandomGraph)$name <- paste0("Node", 1:1000)
#Get the coordinates of the Nodes
Coords <- layout_with_fr(RandomGraph) %>%
as_tibble %>%
bind_cols(data_frame(names = names(V(RandomGraph))))
#Delete random vertices
deletevertex <-sample( V(RandomGraph)$name, 400)
RandomGraph2 <-delete.vertices(RandomGraph, deletevertex)
#get the coordinates of the remaining Nodes
NetCoords <- data_frame(names = names(V(RandomGraph2))) %>%
left_join(Coords, by= "names")
#plot both graphs
RandomGraph%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(Coords[,1:2]))
RandomGraph2%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(NetCoords[,2:3]))
#They nodes have the same relationship to each other but are not laid out in the same position in the frame
setwd("/home/jonno/Create_ETYS_network/SubCode")
source("Setup.R")
View(CalcOverLimit)
View(Cascade)

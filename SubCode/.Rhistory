dat <- expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
print(.x)
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps)
dat <- expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
print(.x)
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>% rowSums
dat <- expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>%
rowSums
gcomps <- components(g)$no #current graph
g0comps <- components(g0)$no #previous graph
gcompsList <- 1:gcomps %>%
map(~ {
newgraph <- delete.vertices(g, components(g)$membership != .x)
get.edge.attribute(newgraph)$name}
)
g0compsList <- 1:g0comps %>%
map(~ {
newgraph <- delete.vertices(g0, components(g0)$membership != .x)
get.edge.attribute(newgraph)$name}
)
dat <- expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>%
rowSums
expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps)
Components_differ<-function(g, g0){
gcomps <- components(g)$no #current graph
g0comps <- components(g0)$no #previous graph
gcompsList <- 1:gcomps %>%
map(~ {
newgraph <- delete.vertices(g, components(g)$membership != .x)
get.edge.attribute(newgraph)$name}
)
g0compsList <- 1:g0comps %>%
map(~ {
newgraph <- delete.vertices(g0, components(g0)$membership != .x)
get.edge.attribute(newgraph)$name}
)
dat <- expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>%
rowSums
}
Components_differ<-function(g, g0){
#This function checks to see which subcomponents have changed in the graph and which are the same.
#using this should be able to cut down on the amount of calculation done on the power flow equations
#g the current graph
#g0 the previous graph
gcomps <- components(g)$no #current graph
g0comps <- components(g0)$no #previous graph
gcompsList <- 1:gcomps %>%
map(~ {
newgraph <- delete.vertices(g, components(g)$membership != .x)
get.edge.attribute(newgraph)$name}
)
g0compsList <- 1:g0comps %>%
map(~ {
newgraph <- delete.vertices(g0, components(g0)$membership != .x)
get.edge.attribute(newgraph)$name}
)
dat <- expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>%
rowSums
}
g0<- testattack[[30]][13]
g <- testattack[[30]][14]
Components_differ(g, g0)
g0<- testattack[[30]][[13]]
g <- testattack[[30]][[14]]
Components_differ(g, g0)
components(g)
SlackRefCasc <-  tibble(name = get.vertex.attribute(g2, "name"),
Bus.Order = get.vertex.attribute(g2, "Bus.Order"),
component = components(g2)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n())
g2 <-g
SlackRefCasc <-  tibble(name = get.vertex.attribute(g2, "name"),
Bus.Order = get.vertex.attribute(g2, "Bus.Order"),
component = components(g2)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n())
View(SlackRefCasc)
View(AttackTheGrid)
AttackTheGrid2 <- function(NetworkList,
AttackStrategy,
referenceGrid = NULL,
MinMaxComp = 0.8,
NodesRemoved = NULL,
StopPoint=Inf,
CascadeMode = TRUE){
#This function attacks the grid using a given attack strategy
#g: Network as an igraph object
#AttackStrategy: A function that calculates which node to delete the function is is in "quo" form
#SubstationData: Dataframe that contains data on the susbtations
#EdgeData: Data frame of Edge data for the network.
#referenceGrid: the grid that will be used to test the largest component against if NULL it uses the given network
#MinMaxComp: The minimum size of the maximum component for the process to continue
if(is.null(NodesRemoved)){
NodesRemoved <- 1
}
#gets the last network in the list
g <- NetworkList[[length(NetworkList)]]
g <- g[[length(g)]]
if(is.null(referenceGrid)){
referenceGrid  <- g
}
#Set the environment of the Attack strategy to inside the function so that the correct g is used
AttackStrategy <- set_env(AttackStrategy, get_env())
#Remove the desired part of the network.
gCasc<- AttackStrategy %>%
eval_tidy
#Rebalence network
#This means that the Cascade calc takes a balanced network which is good.
gCasc <- BalencedGenDem(gCasc, "Demand", "Generation")
gCasc <- list(gCasc)
if(CascadeMode){
#this returns a list of networks each of the cascade
gCasc <- Cascade(gCasc)
}
#concatanate the new list with the list of lists
NetworkList2 <- NetworkList
NetworkList2[[length(NetworkList2)+1]] <-gCasc
#extract the last network from the just completed cascade
gCascLast <- gCasc[[length(gCasc)]]
#If the largest componant is larger than the MinMaxComp threshold
#call the function again and delete a new node.
FractGC <-max(components(gCascLast)$csize)/vcount(referenceGrid)
message(paste("Iteration ",NodesRemoved, " Nodes Remaining", vcount(gCascLast), " GC Fract", round(FractGC,2)))
if( !(FractGC < MinMaxComp | length(NetworkList2)==StopPoint) ){
NetworkList2 <- AttackTheGrid(NetworkList2, AttackStrategy, referenceGrid, MinMaxComp, NodesRemoved+1,StopPoint, CascadeMode)
}
return(NetworkList2)
}
components(g)$no
rep(TRUE, components(g)$no)
Components_differ<-function(g, g0){
#This function checks to see which subcomponents have changed in the graph and which are the same.
#using this should be able to cut down on the amount of calculation done on the power flow equations
#g the current graph
#g0 the previous graph
gcomps <- components(g)$no #current graph
g0comps <- components(g0)$no #previous graph
gcompsList <- 1:gcomps %>%
map(~ {
newgraph <- delete.vertices(g, components(g)$membership != .x)
get.edge.attribute(newgraph)$name}
)
g0compsList <- 1:g0comps %>%
map(~ {
newgraph <- delete.vertices(g0, components(g0)$membership != .x)
get.edge.attribute(newgraph)$name}
)
dat <- expand.grid(1:gcomps, 1:g0comps)
map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>%
(rowSums(.) == 1)
}
g0<- testattack[[30]][[13]]
g <- testattack[[30]][[14]]
Components_differ(g, g0)
dat <- map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>%
rowSums
dat == 0
Components_differ<-function(g, g0){
#This function checks to see which subcomponents have changed in the graph and which are the same.
#using this should be able to cut down on the amount of calculation done on the power flow equations
#g the current graph
#g0 the previous graph
gcomps <- components(g)$no #current graph
g0comps <- components(g0)$no #previous graph
gcompsList <- 1:gcomps %>%
map(~ {
newgraph <- delete.vertices(g, components(g)$membership != .x)
get.edge.attribute(newgraph)$name}
)
g0compsList <- 1:g0comps %>%
map(~ {
newgraph <- delete.vertices(g0, components(g0)$membership != .x)
get.edge.attribute(newgraph)$name}
)
dat <- expand.grid(1:gcomps, 1:g0comps)
dat <- map2_lgl(.x = dat$Var1, .y  = dat$Var2, ~ {
isTRUE(all.equal(gcompsList[[.x]] ,g0compsList[[.y]]))
}
) %>%
matrix(data = . , nrow = gcomps) %>%
rowSums
dat == 0
}
Components_differ(g, g0)
CalcOverLimit2 <- function(g, gComp = NULL){
#This function calculates which edges are over the limit for the current network configuration and demand
#production profile.
#g: a graph with multiple edge and vertex attributes. The graph is assumed to be balenced in demand and production.
#gComp: The previous graph in the series, it is used to check which components are the same as previously only components
#that change are recalculated, this will hopefull save time.
g2 <-g
if(is.null(gComp)){
gComp <- rep(TRUE, components(g)$no)
} else {
gComp <- Components_differ(g, gComp)
}
#finds the slack reference in each component
SlackRefCasc <-  tibble(name = get.vertex.attribute(g2, "name"),
Bus.Order = get.vertex.attribute(g2, "Bus.Order"),
component = components(g2)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n()) %>%
mutate(differ = gComp)
#Calculate power flow for each component of the network as seperate networks
gOut <- 1:nrow(SlackRefCasc) %>%
map(~{
print(paste("PowerFlow for componant", .x))
SlackRef <- SlackRefCasc %>% slice(.x)
g2subset <- delete.vertices(g2, components(g2)$membership != .x)
if(SlackRef$Nodes > 1 & differ){
g2subset <- PowerFlow(g2subset, SlackRef$name)
}
g2subset
}) %>%
Reduce(union2, .)
return(gOut)
}
CalcOverLimit2(g, g0)
SlackRefCasc <-  tibble(name = get.vertex.attribute(g2, "name"),
Bus.Order = get.vertex.attribute(g2, "Bus.Order"),
component = components(g2)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n()) %>%
mutate(differ = gComp)
CalcOverLimit2 <- function(g, g0 = NULL){
#This function calculates which edges are over the limit for the current network configuration and demand
#production profile.
#g: a graph with multiple edge and vertex attributes. The graph is assumed to be balenced in demand and production.
#gComp: The previous graph in the series, it is used to check which components are the same as previously only components
#that change are recalculated, this will hopefull save time.
if(is.null(gComp)){
g0 <- rep(TRUE, components(g)$no)
} else {
g0 <- Components_differ(g, g0)
}
#finds the slack reference in each component
SlackRefCasc <-  tibble(name = get.vertex.attribute(g, "name"),
Bus.Order = get.vertex.attribute(g, "Bus.Order"),
component = components(g)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n()) %>%
mutate(differ = gComp)
#Calculate power flow for each component of the network as seperate networks
gOut <- 1:nrow(SlackRefCasc) %>%
map(~{
print(paste("PowerFlow for componant", .x))
SlackRef <- SlackRefCasc %>% slice(.x)
g2subset <- delete.vertices(g, components(g)$membership != .x)
if(SlackRef$Nodes > 1 & differ){
g2subset <- PowerFlow(g2subset, SlackRef$name)
}
g2subset
}) %>%
Reduce(union2, .)
return(gOut)
}
SlackRefCasc <-  tibble(name = get.vertex.attribute(g, "name"),
Bus.Order = get.vertex.attribute(g, "Bus.Order"),
component = components(g)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n()) %>%
mutate(differ = gComp)
if(is.null(g0)){
g0 <- rep(TRUE, components(g)$no)
} else {
differ <- Components_differ(g, g0)
}
g0<- testattack[[30]][[13]]
g <- testattack[[30]][[14]]
if(is.null(g0)){
differ <- rep(TRUE, components(g)$no)
} else {
differ <- Components_differ(g, g0)
}
differ
SlackRefCasc <-  tibble(name = get.vertex.attribute(g, "name"),
Bus.Order = get.vertex.attribute(g, "Bus.Order"),
component = components(g)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n()) %>%
mutate(differ = differ)
View(SlackRefCasc)
CalcOverLimit2(g, g0)
CalcOverLimit2 <- function(g, g0 = NULL){
#This function calculates which edges are over the limit for the current network configuration and demand
#production profile.
#g: a graph with multiple edge and vertex attributes. The graph is assumed to be balenced in demand and production.
#gComp: The previous graph in the series, it is used to check which components are the same as previously only components
#that change are recalculated, this will hopefull save time.
if(is.null(g0)){
differ <- rep(TRUE, components(g)$no)
} else {
differ <- Components_differ(g, g0)
}
#finds the slack reference in each component
SlackRefCasc <-  tibble(name = get.vertex.attribute(g, "name"),
Bus.Order = get.vertex.attribute(g, "Bus.Order"),
component = components(g)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n()) %>%
mutate(differ = differ)
#Calculate power flow for each component of the network as seperate networks
gOut <- 1:nrow(SlackRefCasc) %>%
map(~{
print(paste("PowerFlow for componant", .x))
SlackRef <- SlackRefCasc %>% slice(.x)
g2subset <- delete.vertices(g, components(g)$membership != .x)
if(SlackRef$Nodes > 1 & differ){
g2subset <- PowerFlow(g2subset, SlackRef$name)
}
g2subset
}) %>%
Reduce(union2, .)
return(gOut)
}
CalcOverLimit2(g, g0)
CalcOverLimit2 <- function(g, g0 = NULL){
#This function calculates which edges are over the limit for the current network configuration and demand
#production profile.
#g: a graph with multiple edge and vertex attributes. The graph is assumed to be balenced in demand and production.
#gComp: The previous graph in the series, it is used to check which components are the same as previously only components
#that change are recalculated, this will hopefull save time.
if(is.null(g0)){
differ <- rep(TRUE, components(g)$no)
} else {
differ <- Components_differ(g, g0)
}
#finds the slack reference in each component
SlackRefCasc <-  tibble(name = get.vertex.attribute(g, "name"),
Bus.Order = get.vertex.attribute(g, "Bus.Order"),
component = components(g)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n())
#Calculate power flow for each component of the network as seperate networks
gOut <- 1:nrow(SlackRefCasc) %>%
map(~{
print(paste("PowerFlow for componant", .x))
SlackRef <- SlackRefCasc %>% slice(.x)
g2subset <- delete.vertices(g, components(g)$membership != .x)
if(SlackRef$Nodes > 1 && differ){
g2subset <- PowerFlow(g2subset, SlackRef$name)
}
g2subset
}) %>%
Reduce(union2, .)
return(gOut)
}
CalcOverLimit2(g, g0)
CalcOverLimit2 <- function(g, g0 = NULL){
#This function calculates which edges are over the limit for the current network configuration and demand
#production profile.
#g: a graph with multiple edge and vertex attributes. The graph is assumed to be balenced in demand and production.
#gComp: The previous graph in the series, it is used to check which components are the same as previously only components
#that change are recalculated, this will hopefull save time.
if(is.null(g0)){
differ <- rep(TRUE, components(g)$no)
} else {
differ <- Components_differ(g, g0)
}
#finds the slack reference in each component
SlackRefCasc <-  tibble(name = get.vertex.attribute(g, "name"),
Bus.Order = get.vertex.attribute(g, "Bus.Order"),
component = components(g)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n())
#Calculate power flow for each component of the network as seperate networks
gOut <- 1:nrow(SlackRefCasc) %>%
map(~{
#print(paste("PowerFlow for componant", .x))
SlackRef <- SlackRefCasc %>% slice(.x)
g2subset <- delete.vertices(g, components(g)$membership != .x)
if(SlackRef$Nodes > 1 && differ){
g2subset <- PowerFlow(g2subset, SlackRef$name)
}
g2subset
}) %>%
Reduce(union2, .)
return(gOut)
}
library(microbenchmark)
?microbenchmark
bench <- microbenchmark(CalcOverLimit2(g, g0), CalcOverLimit(g))
bench
SlackRef$Nodes > 1 && differ
CalcOverLimit2 <- function(g, g0 = NULL){
#This function calculates which edges are over the limit for the current network configuration and demand
#production profile.
#g: a graph with multiple edge and vertex attributes. The graph is assumed to be balenced in demand and production.
#gComp: The previous graph in the series, it is used to check which components are the same as previously only components
#that change are recalculated, this will hopefull save time.
if(is.null(g0)){
differ <- rep(TRUE, components(g)$no)
} else {
differ <- Components_differ(g, g0)
}
#finds the slack reference in each component
SlackRefCasc <-  tibble(name = get.vertex.attribute(g, "name"),
Bus.Order = get.vertex.attribute(g, "Bus.Order"),
component = components(g)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n()) %>%
mutate(differ = differ)
#Calculate power flow for each component of the network as seperate networks
gOut <- 1:nrow(SlackRefCasc) %>%
map(~{
#print(paste("PowerFlow for componant", .x))
SlackRef <- SlackRefCasc %>% slice(.x)
g2subset <- delete.vertices(g, components(g)$membership != .x)
if(SlackRef$Nodes > 1 && SlackRef$differ){
g2subset <- PowerFlow(g2subset, SlackRef$name)
}
g2subset
}) %>%
Reduce(union2, .)
return(gOut)
}
bench <- microbenchmark(CalcOverLimit2(g, g0), CalcOverLimit(g), times = 10)
bench
differ
CalcOverLimit <- function(g){
#This function calculates which edges are over the limit for the current network configuration and demand
#production profile.
#g: a graph with multiple edge and vertex attributes. The graph is assumed to be balenced in demand and production.
g2 <-g
#finds the slack reference in each component
SlackRefCasc <-  tibble(name = get.vertex.attribute(g2, "name"),
Bus.Order = get.vertex.attribute(g2, "Bus.Order"),
component = components(g2)$membership) %>%
group_by(component) %>%
arrange(Bus.Order) %>%
summarise(name = first(name),
Nodes = n())
#Calculate power flow for each component of the network as seperate networks
gOut <- 1:nrow(SlackRefCasc) %>%
map(~{
#print(paste("PowerFlow for componant", .x))
SlackRef <- SlackRefCasc %>% slice(.x)
g2subset <- delete.vertices(g2, components(g2)$membership != .x)
if(SlackRef$Nodes > 1){
g2subset <- PowerFlow(g2subset, SlackRef$name)
}
g2subset
}) %>%
Reduce(union, .)
return(gOut)
}
set.seed(15)
testattack <- suppressMessages(AttackTheGrid(list(list(gbase)), FixedNodes, MinMaxComp = 0.8, CascadeMode = TRUE))

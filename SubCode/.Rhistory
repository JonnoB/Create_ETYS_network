#Returns an impedance matrix
Impmat <- df[,1:2] %>%
as.matrix %>%
graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(df[,3])
Impmat <- as_adjacency_matrix(Impmat, attr = "weight") %>% as.matrix
diag(Impmat ) <- -rowSums(Impmat )
Impmat  <- -Impmat
return(Impmat)
}
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
test <- Impedance %>% select(Node1,Node2, ImpInvS)
View(test)
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
df <- Impedance
Impmat <- df[,1:2] %>%
as.matrix %>%
graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(df[,3])
as.numeric(df[,3])
df[,3]
as.numeric(df[,3])
as.numeric(unlist(df[,3]))
E(Impmat)$weight <- as.numeric(unlist(df[,3]))
rm(df)
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
CreateImpedance <- function(df){
#takes a three column dataframe where the first two columns are the node that the edge will connect to
#The third column is the impedance of the edge.
#Returns an impedance matrix
Impmat <- df[,1:2] %>%
as.matrix %>%
graph_from_edgelist(., directed = FALSE)
E(Impmat)$weight <- as.numeric(unlist(df[,3]))
Impmat <- as_adjacency_matrix(Impmat, attr = "weight") %>% as.matrix
diag(Impmat ) <- -rowSums(Impmat )
Impmat  <- -Impmat
return(Impmat)
}
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance(.)
View(test)
test <- Impedance %>% select(Node1,Node2, ImpInvS) %>%
CreateImpedance
Impmat<- Impedance %>%
select(Node1,Node2, ImpInvS) %>%
CreateImpedance
rm(test)
Admat<- Impedance %>%
muatet(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
CreateImpedance
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
CreateImpedance
View(Admat)
#Create impedance using X
Impmat<- Impedance %>%
select(Node1,Node2, X*MVA) %>%
CreateImpedance
#Create impedance using X
Impmat2 <- Impedance %>%
mutate(X2 = X*MVA ) %>%
select(Node1,Node2, X*MVA) %>%
CreateImpedance
#Create impedance using X
Impmat2 <- Impedance %>%
mutate(X2 = X*MVA ) %>%
select(Node1,Node2, X2) %>%
CreateImpedance
View(RCE)
View(Impmat2)
packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr")
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(packages, library, character.only = TRUE)
#Set up file system to read the correct folders this switches between aws and windows mode
datafile<- "/home/jonno/Dropbox/Jonathan Bourne Phd Folder/ETYSAppendixB"
Functions <-"/home/jonno/Create_ETYS_network/Functions"
list.files(Functions) %>% map(~source(file.path(Functions,.x)))
```
#Loading and creating a structure for the data
```{r}
#create the path to the file
path <- file.path(datafile, "ETYS 2016 Appendix B.xlsx")
#Create a list of all the sheets in the file
AllData <- path %>%
excel_sheets(.) %>%
lapply(., read_excel, path = path, skip = 1, trim_ws = TRUE ) %>%
map(~.x %>% setNames(make.names(names(.))))
#break out the sheet names
AllData[[1]] <- AllData[[1]] %>%
setNames(c("Table", "Title")) %>%
filter(complete.cases(.)) %>%
mutate(Table = replace(Table, Table=="Table", "Index"),
element = 1:(n())) #provides list element reference
names(AllData) <- AllData[[1]]$Table
View(AllData$Index)
```
#Create base data
```{r}
Substation <- StackList(2:4) %>%
mutate(Site.Code = str_trim(Site.Code),
Site.Name = str_trim(Site.Name)) #remove leading and trailing whitespace which causes problems with analysis.
Circuits <- StackList(6:8)
names(AllData[[16]])[1:2] <-c("Node1", "Node2") #The name had been written differently to the other two
Transformers <- StackList(14:16)
#The RCE needs a lot of treatment as there are formatting differences and also the bind_rows part of map_df doesn't coerce, which is annoying.
names(AllData[[24]])[4] <-"MVAr.Generation"
names(AllData[[23]])[5] <-"MVAr.Absorbtion"
names(AllData[[24]])[5] <-"MVAr.Absorbtion"
AllData[[22]]$MVAr.Absorption<- AllData[[22]]$MVAr.Absorption %>%gsub("[^A-Z0-9]", "", ., ignore.case = TRUE)
RCE<- AllData[22:24] %>% map(~.x %>% RemoveSymbols %>%
mutate(Unit.Number = as.character(Unit.Number),
Connection.Voltage..kV. = as.character(Connection.Voltage..kV.)))%>%
map2_df(.x =.,
.y = names(.),
~ .x %>%
mutate(Table =.y ) )
demand <- read_excel(file.path(datafile,"ETYS16 AppG demand data.xlsx"), skip = 7)
#Percent f demand that matches a nodes
sum(unique(demand$Node) %in% unique(FullnameCounts$Name))/length(unique(demand$Node))
#check using just site this matches loads
sum(str_sub(unique(demand$Node),1,4) %in% str_sub(unique(FullnameCounts$Name),1,4))/length(unique(demand$Node))
demand2 <- FullnameCounts %>% filter(grepl("AMEM", Name))
test <- FullnameCounts %>% filter(Name %in% unique(demand$Node))
demand2 <- demand %>% filter(grepl("BEAU", Node))
Impedance <- bind_rows(mutate(Circuits, MVA=Spring.Rating..MVA.,
Type = "Circuit"),
mutate(Transformers, MVA = Rating..MVA.,
Type = "Transformer")) %>%
select(Node1, Node2, R....on.100MVA., X....on.100MVA., B....on.100MVA.,
MVA, Type) %>%
mutate(
R = R....on.100MVA./100,
X = X....on.100MVA./100,
B = B....on.100MVA./100,
MVA = round(MVA, 0),
ImpInvS = 1/B,
ImpRX =  complex(real = R, imaginary = X),
ImpInvS2 = 1/(B*MVA),
ImpRX2 = complex(real = R, imaginary = X)*MVA,
B2 = -X/(R^2+X^2)) %>%
#create the voltage matching
mutate(Node1b = str_sub(Node1, 1, 4),
Node2b = str_sub(Node2, 1, 4))
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
CreateImpedance
nrow(Admat)
union_all(rownames(Admat))
unique(rownames(Admat))
unique(rownames(Admat)) %>% length
View(CreateImpedance)
View(CreateImpedance)
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2)
View(Admat)
#Create addmitance using 1/X
Admat<- Impedance %>%
mutate(B2 = 1/(X*MVA) ) %>%
select(Node1,Node2, B2) %>%
group_by(Node1,Node2) %>%
summarise(B2 = sum(B2)) %>%
CreateImpedance
nrow(Admat)
MinVolt <- Substation %>%
group_by(Site.Code) %>%
summarise(V = min(Voltage..kV.))
Voltagemaker <- left_join(data.frame(Node = colnames(Admat)),
demand, by = "Node") %>%
group_by(Node) %>%
mutate_all(funs(ifelse(is.na(.),0,1)))%>%
ungroup %>%
.[,c(1,3)] %>%
mutate(Site.Code = str_sub(Node, 1,4)) %>%
left_join(., MinVolt, by = "Site.Code") %>%
mutate(V = ifelse(is.na(V),0, V)) #some nodes don't have a site, these are set to 0
test <- CreateTransmission(Impedance, "Node1", "Node2", "B2")
CreateTransmission <- function(df, StartNode, EndNode, edgeweight){
df <- df %>% rename_(Node1 = StartNode,
Node2 = EndNode,
EdgeWeight = edgeweight) %>%
mutate(Edgename = paste(Node1,Node2, sep = "-"))
df2 <- df %>% select(Edgename, Node1, EdgeWeight)
df3 <- df %>% select(Edgename, Node2, EdgeWeight) %>%
mutate(EdgeWeight = -EdgeWeight) %>%
rename(Node1 = Node2)
df <- bind_rows(df2, df3) %>%
spread(., Node1, EdgeWeight, fil = 0)
Transmat <- df
# Transmat <- df[,1:2] %>%
#   as.matrix %>%
#   graph_from_edgelist(., directed = FALSE)
#
# E(Transmat)$weight <- as.numeric(unlist(df[,3]))
#
# Transmat <- as_adjacency_matrix(Transmat, attr = "weight") %>% as.matrix
return(Transmat)
}
test <- CreateTransmission(Impedance, "Node1", "Node2", "B2")
View(Impedance)
CreateTransmission <- function(df, StartNode, EndNode, edgeweight){
df <- df %>% rename_(Node1 = StartNode,
Node2 = EndNode,
EdgeWeight = edgeweight) %>%
group_by(Node1, Node2) %>%
mutate(Edgename = paste(Node1,Node2, 1:n(),sep = "-")) %>% ungroup
df2 <- df %>% select(Edgename, Node1, EdgeWeight)
df3 <- df %>% select(Edgename, Node2, EdgeWeight) %>%
mutate(EdgeWeight = -EdgeWeight) %>%
rename(Node1 = Node2)
df <- bind_rows(df2, df3) %>%
spread(., Node1, EdgeWeight, fil = 0)
Transmat <- df
# Transmat <- df[,1:2] %>%
#   as.matrix %>%
#   graph_from_edgelist(., directed = FALSE)
#
# E(Transmat)$weight <- as.numeric(unlist(df[,3]))
#
# Transmat <- as_adjacency_matrix(Transmat, attr = "weight") %>% as.matrix
return(Transmat)
}
test <- Impedence %>%
CreateTransmission(., "Node1", "Node2", "B2")
test <- Impedance %>%
CreateTransmission(., "Node1", "Node2", "B2")
source('~/Create_ETYS_network/Functions/CreateTransmission.R')
source('~/Create_ETYS_network/Functions/CreateTransmission.R')
CreateTransmission <- function(df, StartNode, EndNode, edgeweight){
df <- df %>% rename_(Node1 = StartNode,
Node2 = EndNode,
EdgeWeight = edgeweight) %>%
#mutate(Edgename = paste(Node1,Node2, sep = "-"))
group_by(Node1, Node2) %>% #trying to stop the non-unique identifier problem
mutate(Edgename = paste(Node1,Node2, 1:n(),sep = "-")) %>% ungroup
df2 <- df %>% select(Edgename, Node1, EdgeWeight)
df3 <- df %>% select(Edgename, Node2, EdgeWeight) %>%
mutate(EdgeWeight = -EdgeWeight) %>%
rename(Node1 = Node2)
df <- bind_rows(df2, df3) %>%
spread(., Node1, EdgeWeight, fil = 0)
Transmat <- df
# Transmat <- df[,1:2] %>%
#   as.matrix %>%
#   graph_from_edgelist(., directed = FALSE)
#
# E(Transmat)$weight <- as.numeric(unlist(df[,3]))
#
# Transmat <- as_adjacency_matrix(Transmat, attr = "weight") %>% as.matrix
return(Transmat)
}
test <- Impedance %>%
CreateTransmission(., "Node1", "Node2", "B2")
Impedance %>% select(Node1, Node2, B2) %>% slice(1976,4385)
Impedance %>% select(Node1, Node2, B2) %>% slice(c(1976,4385))
?slice
Impedance %>% select(Node1, Node2, B2) .[c(1976,4385),]
Impedance %>% select(Node1, Node2, B2) %>% .[c(1976,4385),]
52/76
1-52/76
library(igrpah); ibrary(dplyr)
#generate random graph
set.seed(500)
RandomGraph <- sample_gnm(1000, 2500)
#name nodes
V(RandomGraph)$name <- paste0("Node", 1:1000)
#Get the coordinates of the Nodes
Coords <- layout_with_fr(RandomGraph) %>%
as_tibble %>%
bind_cols(data_frame(names = names(V(RandomGraph))))
#Delete random vertices
deletevertex <-sample( V(RandomGraph)$name, 400)
RandomGraph2 <-delete.vertices(RandomGraph, deletevertex)
#get the coordinates of the remaining Nodes
NetCoords <- data_frame(names = names(V(RandomGraph2))) %>%
left_join(Coords, by= "names")
#plot both graphs
RandomGraph%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(Coords[,1:2]))
RandomGraph2%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(NetCoords[,2:3]))
#They nodes have the same relationship to each other but are not laid out in the same position in the frame
library(igrpah); ibrary(dplyr)
library(igraph); ibrary(dplyr)
#generate random graph
set.seed(500)
RandomGraph <- sample_gnm(1000, 2500)
#name nodes
V(RandomGraph)$name <- paste0("Node", 1:1000)
#Get the coordinates of the Nodes
Coords <- layout_with_fr(RandomGraph) %>%
as_tibble %>%
bind_cols(data_frame(names = names(V(RandomGraph))))
#Delete random vertices
deletevertex <-sample( V(RandomGraph)$name, 400)
RandomGraph2 <-delete.vertices(RandomGraph, deletevertex)
#get the coordinates of the remaining Nodes
NetCoords <- data_frame(names = names(V(RandomGraph2))) %>%
left_join(Coords, by= "names")
#plot both graphs
RandomGraph%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(Coords[,1:2]))
RandomGraph2%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(NetCoords[,2:3]))
#They nodes have the same relationship to each other but are not laid out in the same position in the frame
library(igraph); library(dplyr)
#generate random graph
set.seed(500)
RandomGraph <- sample_gnm(1000, 2500)
#name nodes
V(RandomGraph)$name <- paste0("Node", 1:1000)
#Get the coordinates of the Nodes
Coords <- layout_with_fr(RandomGraph) %>%
as_tibble %>%
bind_cols(data_frame(names = names(V(RandomGraph))))
#Delete random vertices
deletevertex <-sample( V(RandomGraph)$name, 400)
RandomGraph2 <-delete.vertices(RandomGraph, deletevertex)
#get the coordinates of the remaining Nodes
NetCoords <- data_frame(names = names(V(RandomGraph2))) %>%
left_join(Coords, by= "names")
#plot both graphs
RandomGraph%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(Coords[,1:2]))
RandomGraph2%>%
plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label = NA, layout = as.matrix(NetCoords[,2:3]))
#They nodes have the same relationship to each other but are not laid out in the same position in the frame
setwd("/home/jonno/Create_ETYS_network/SubCode")
source("Setup.R")
```
#Load Tariff and Trasnport
```{r}
KeepPath <- getwd()
#Load Tariff aka generation data
setwd(Tariff)
GenerationData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =10, skip = 33) %>%
setNames(make.names(names(.))) %>%
mutate(Site = str_sub(Node.1,1,4))
LocalAssetData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =11, skip = 11) %>%
setNames(make.names(names(.)))
TransportData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =12, skip = 11) %>%
setNames(make.names(names(.)))
setwd(KeepPath)
rm(KeepPath)
```
#Clean and seperate Transport
```{r}
trans1 <-TransportData[,1:16] %>%
filter(!is.na(Bus.ID))
trans2 <- TransportData[,17:59] %>%
filter(!is.na(Bus.1)) %>%
group_by(Bus.1, Bus.2) %>% #trying to stop the non-unique identifier problem
mutate(Link = paste(Bus.1,Bus.2, 1:n(),sep = "-")) %>% #This allows multiple edges
#between the same node pair, it is not certain the data is always correct!
ungroup %>%
group_by(Bus.1, Bus.2) %>% #trying to stop the non-unique identifier problem
mutate(Link = paste(Bus.1,Bus.2, 1:n(),sep = "-")) %>% #This allows multiple edges
#between the same node pair, it is not certain the data is always correct!
ungroup  %>%
#set construct line limits really high
mutate(Link.Type = tolower(Link.Type),
Link.Limit = ifelse(Link.Type == "construct", 1e5, Link.Limit)) %>%
#add in susceptance
mutate(Y = 1/X..Peak.Security.)
```
```{r}
VertexMetaData <- trans1 %>%
select(Bus.Name,
Voltage,
Demand,
Generation = Generation.B.....Year.Round...Transport.Model.,
BalencedPower = BusTransferB,
Bus.Order)
gbase <- trans2 %>%
#this mutate is because the base limits cause a rolling blackout due to the below lines being overpowered
# mutate(Link.Limit = case_when(
#   Link == "BRAC20-BONB20-1" ~826,
#   Link == "FAUG10-LAGG1Q-1" ~826,
#   Link == "KEIT20-KINT20-1" ~500,
#   Link == "LAGG1Q-MILW1S-1" ~826,
#   TRUE ~ Link.Limit
# )) %>%
select(Bus.1,
Bus.2,
Y,
Link.Limit,
Link) %>%
mutate(PowerFlow = 0) %>%
graph_from_data_frame(., directed=FALSE, vertices = VertexMetaData)
gbase <- set.vertex.attribute(gbase, "component", value = components(gbase)$membership)
If the voltage of the from node is equal to the voltage of the two node then the line voltage is also the same, otherwise the line is a transformer and the voltage is 0
EdgeVoltage <- ifelse(
get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,1])== get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,2]),
get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,1]),
0)
gbase <- set_edge_attr(gbase, "Voltage", value = EdgeVoltage)
RandomAttack <-function(graph = g, Nodes = 1, seed = NULL){
#remmoves a random node from the graph
#g: the netowrk which is being attacked
#Nodes: the Number of Nodes to Remove
#seed: The random number generator to use. This is optional
if(is.null(seed)){
set.seed(seed)
}
deletevertex <- sample(V(g)$name, 1)
print(deletevertex)
#remove selected node from network
newgraph <- delete.vertices(g, deletevertex)
return(newgraph)
}
RandomAttack()
AttackStrategy <-quote(RandomAttack())
AttackTheGrid <- function(NetworkList, AttackStrategy, referenceGrid = NULL, MinMaxComp = 0.8, NodesRemoved = NULL, StopPoint=Inf){
#This function attacks the grid using a given attack strategy
#g: Network as an igraph object
#AttackStrategy: A function that calculates which node to delete the function is is in "quo" form
#SubstationData: Dataframe that contains data on the susbtations
#EdgeData: Data frame of Edge data for the network.
#referenceGrid: the grid that will be used to test the largest component against if NULL it uses the given network
#MinMaxComp: The minimum size of the maximum component for the process to continue
if(is.null(NodesRemoved)){
NodesRemoved <- 1
}
print(NodesRemoved)
#gets the last network in the list
g <- NetworkList[[length(NetworkList)]]
print(paste("list of lists length", length(NetworkList)))
print(paste("list length", length(g)))
g <- g[[length(g)]]
if(is.null(referenceGrid)){
referenceGrid  <- g
}
#deletevertex <- eval(AttackStrategy)
#print(deletevertex)
#remove selected node from network
gCasc <- eval(AttackStrategy)#delete.vertices(g, deletevertex)
#this returns a list of networks each of the cascade
gCasc <- Cascade(list(gCasc))
#concatanate the new list with the list of lists
NetworkList2 <- NetworkList
NetworkList2[[length(NetworkList2)+1]] <-gCasc
#extract the last network from the just completed cascade
gCascLast <- gCasc[[length(gCasc)]]
#If the largest componant is larger than the MinMaxComp threshold
#call the function again and delete a new node.
print(paste("Number of nodes Remaining", vcount(gCascLast)))
FractGC <-max(components(gCascLast)$csize)/vcount(referenceGrid)
print(paste("Fraction of total nodes in GC", FractGC))
if( !(FractGC < MinMaxComp | length(NetworkList2)==StopPoint) ){
NetworkList2 <- AttackTheGrid(NetworkList2, AttackStrategy, referenceGrid, MinMaxComp, NodesRemoved+1,StopPoint)
}
return(NetworkList2)
}
set.seed(15)
test <- list(gbase) %>%
list %>%
AttackTheGrid(., AttackStrategy, MinMaxComp = 0.8)
print(AttackStrategy)
RandomAttack <-function(graph = g, Nodes = 1, seed = NULL){
#remmoves a random node from the graph
#g: the netowrk which is being attacked
#Nodes: the Number of Nodes to Remove
#seed: The random number generator to use. This is optional
if(is.null(seed)){
set.seed(seed)
}
deletevertex <- sample(V(graph)$name, 1)
print(deletevertex)
#remove selected node from network
newgraph <- delete.vertices(graph, deletevertex)
return(newgraph)
}
AttackStrategy <-quote(RandomAttack())
set.seed(15)
test <- list(gbase) %>%
list %>%
AttackTheGrid(., AttackStrategy, MinMaxComp = 0.8)
set.seed(15)
test <- list(gbase) %>%
list %>%
AttackTheGrid(., AttackStrategy, MinMaxComp = 0.8)
set.seed(15)
test <- list(gbase) %>%
list %>%
AttackTheGrid(., AttackStrategy, MinMaxComp = 0.8)
RandomAttack <-function(graph = g, Nodes = 1, seed = NULL){
#remmoves a random node from the graph
#g: the netowrk which is being attacked
#Nodes: the Number of Nodes to Remove
#seed: The random number generator to use. This is optional
if(is.null(seed)){
set.seed(seed)
}
deletevertex <- sample(V(graph)$name, 1)
print(deletevertex)
#remove selected node from network
newgraph <- delete.vertices(graph, deletevertex)
return(newgraph)
}
AttackStrategy <-quote(RandomAttack())
set.seed(15)
test <- list(gbase) %>%
list %>%
AttackTheGrid(., AttackStrategy, MinMaxComp = 0.8)

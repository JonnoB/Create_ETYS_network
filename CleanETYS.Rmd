---
title: "Networking the ETYS"
author: "Jonathan Bourne"
date: "2 May 2017"
output: html_document
---


```{r Setup}
packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


lapply(packages, library, character.only = TRUE)


#Set up file system to read the correct folders this switches between aws and windows mode


datafile<- "/home/jonno/Dropbox/Jonathan Bourne Phd Folder/ETYSAppendixB"

```

#Functions

```{r}
StackList <- function(elements)  {
  AllData[elements]%>%
  map2_df(.x =.,
                     .y = names(.),
                     ~ .x %>% 
                      mutate(Table =.y ) %>% RemoveSymbols
  )}


RemoveSymbols <-function(df)  {
  df  %>% mutate_all( funs(gsub("^[^A-Z0-9]{1,}", "", ., ignore.case = FALSE))) %>%
     map_df(parse_guess) 
}


```



#Loading and creating a structure for the data

```{r}
#create the path to the file
path <- file.path(datafile, "ETYS 2016 Appendix B.xlsx")


#Create a list of all the sheets in the file

AllData <- path %>% 
  excel_sheets(.) %>%
lapply(., read_excel, path = path, skip = 1, trim_ws = TRUE ) %>%
  map(~.x %>% setNames(make.names(names(.))))

#break out the sheet names

AllData[[1]] <- AllData[[1]] %>% 
  setNames(c("Table", "Title")) %>% 
  filter(complete.cases(.)) %>%
  mutate(Table = replace(Table, Table=="Table", "Index"), 
         element = 1:(n())) #provides list element reference

names(AllData) <- AllData[[1]]$Table

View(AllData$Index)

```

#Structuring the substations

Take index of substation codes and combine into a single table 
```{r}

Substation <- StackList(2:4) %>%
  mutate(Site.Code = str_trim(Site.Code),
         Site.Name = str_trim(Site.Name)) #remove leading and trailing whitespace which causes problems with analysis.

#I'm not sure why the OFTO is different and therfore cannot be incuded

#How many site codes are there?

length(unique(Substation$Site.Code))

#Howmany when the results are split by organisation?

Substation %>% split(.$Table) %>% map_dbl(~length(unique(.x$Site.Code))) %>% sum

#The results of these two tests show that the different tables contain identical codes. These need to be identified.

OverlappingSubstations <- Substation %>% split(.$Table) %>% 
  map(~data.frame(unique(Substation$Site.Code) %in% .x$Site.Code))  %>%
  bind_cols() %>% setNames(unique(Substation$Table))%>% 
  mutate(tots = rowSums(.)) %>%
  bind_cols(data.frame(Site.Code = unique(Substation$Site.Code)),.) %>%
  filter(tots>1) %>% left_join(., Substation)

#This overlapping data frame shows which nodes overlap across tables. It also shows that the different organisation may not have the same voltages. For example Invernan (INVR) SHE has 132 and 33 Kv connections whilst SPT has 275kv. 
#The overlapping table also reveals an issue with the naming convention. the code LOCH is used for both the substation by Lochay hydro plant and also the substation by Loch Hill windfarm which are over 100 miles apart. 

#Checking for multiple uses of the same code in different substations to see how many times events like "LOCH" occur.

DoubleNames <- Substation %>% group_by(Site.Code, Site.Name) %>% summarise(counts =n()) %>% 
  ungroup %>%
  group_by(Site.Code) %>% mutate(reps = n()) %>% ungroup %>% filter(reps>1)

#This is a common occurance for the doubles, there are two occurances one the name the other with "windfarm" added on. This needs to be investigated to check whether they are in the same physical location or not. 
Substation %>% filter(Site.Code == "BIRN")

#Although several of the doubles are spelling mistakes.
#Further investigation needs to be made to see whether these doubles are the same point or are different physical locations.

```

#Structuring the circuits.



```{r Cicuits}
Circuits <- StackList(6:8)

#Are all the codes of the same length?
nchar(Circuits$Node1) %>% table
nchar(Circuits$Node2) %>% table
#No. However the substation codes are all exactly 4 character long. What does this mean? 
#It is not to do with the OFTO parts.
nchar(Substation$Site.Code) %>% table

Circuits %>% filter(nchar(Node2) ==5)
Circuits %>% filter(nchar(Node2) ==8)


```

```{r CircuitsChange}
circuits_change <-  StackList(10:12)
#What are the different Status possible with the changes?
unique(circuits_change$Status)
#What is the difference between delete and remove?

```

#Transformers

```{r transformers}

names(AllData[[16]])[1:2] <-c("Node1", "Node2") #The name had been written differently to the other two
Transformers <- StackList(14:16)

```


```{r transformers_change}
names(AllData[[20]])[1:2] <-c("Node1", "Node2") #The name had been written differently to the other two
transformers_change <- StackList(18:20)

```


#Reactive Compensation Equipment

RCE

The RCE needs a lot of treatment as there are formatting differences and also the bind_rows part of map_df doesn't coerce, which is annoying.
```{r RCE}



names(AllData[[24]])[4] <-"MVAr.Generation"
names(AllData[[23]])[5] <-"MVAr.Absorbtion"
names(AllData[[24]])[5] <-"MVAr.Absorbtion"

AllData[[22]]$MVAr.Absorption<- AllData[[22]]$MVAr.Absorption %>%gsub("[^A-Z0-9]", "", ., ignore.case = TRUE)


RCE<- AllData[22:24] %>% map(~.x %>% RemoveSymbols %>% 
                                 mutate(Unit.Number = as.character(Unit.Number),
                                        Connection.Voltage..kV. = as.character(Connection.Voltage..kV.)))%>%
  map2_df(.x =.,
                     .y = names(.),
                     ~ .x %>% 
                      mutate(Table =.y ) )

```

#OFTO

```{r}

  AllData[[24]] %>% sapply(.,class)
  AllData[[22]]$MVAr.Generation %>% table
  AllData[[23]]$MVAr.Generation %>% table
  AllData[[24]]$MVAr.Generation %>% table
  
AllData[[22]]$MVAr.Absorption %>%gsub("[^A-Z0-9]", "", ., ignore.case = FALSE)

```



#Make a circuit network

Some experiments to get a sensible looking network working


One idea may be to build up a single site into a complete graph, a good example would be harker as it has 8 units.

```{r}
#find the substation with the most occurances
data_frame(Names =  c(str_sub(Circuits$Node1,  1,4),str_sub(Circuits$Node2,  1,4))) %>%
  group_by(Names) %>%
  summarise(Counts = n()) %>%
  arrange(-Counts)

#sublist <- Circuits %>% filter(grepl("ABNE", .$Node1)|grepl("ABNE", .$Node2))

#This network has a lot of isolated nodes
graph1 <-graph_from_edgelist(as.matrix(Circuits[,1:2]), directed = FALSE)
degree(graph1) %>% table
plot(graph1)

#To get around the above problem I will only use the 4 character identifier to construct the network.

graph2 <- Circuits %>% mutate(Node14 = str_sub(Node1,  1,4),
                    Node24 = str_sub(Node2,  1,4))
graph2 <- graph_from_edgelist(el =graph2 %>% select(Node14, Node24) %>% as.matrix, directed = FALSE)
degree(graph2) %>% table #huge reduction in isolated nodes
graph2 %>% 
  simplify(., remove.multiple = F, remove.loops = T) %>% 
  plot(., edge.arrow.size=.4, vertex.label=NA)

```


One issue is that it is difficult to know what everything is linking two, inorder to get a greater undersstanding I will try to match the full names to everything else and see how many have a match and how many don't

```{r}

FullnameCounts <- list(
  data_frame(Name = c(Circuits$Node1, Circuits$Node2), Type = "Circuits"),
data_frame(Name = c(Transformers$Node1, Transformers$Node2), Type = "Transformers"),
data_frame(Name =RCE$Node, Type = "RCE")) %>%
  bind_rows %>%
group_by(Name, Type) %>%
  summarise(Count = n()) %>%
  arrange(-Count) %>%
group_by(Name) %>%
  mutate(Total = sum(Count),
         TypeCounts = n()) %>% 
  ungroup

#Add in the amount of times a site appears
FullnameCounts <- FullnameCounts %>%
  mutate(Site = str_sub(Name, 1,4)) %>%
  group_by(Site) %>%
  mutate(SiteCount = sum(Count),
         SiteTypeCounts = unique(Type) %>% length) %>%
  ungroup


#Of the 1034 occurances 322 names only occur once, it is then important to try and match these to the other types of node.
 table(FullnameCounts$Count)



FullnameCounts <- data_frame(Names = c(Transformers$Node1, Transformers$Node2)) %>%
  group_by(Names) %>%
  summarise(Counts = n()) %>%
  arrange(-Counts)


```
1

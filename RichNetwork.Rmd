---
title: "Graph based functions"
author: "Jonathan Bourne"
date: "11 September 2017"
output: html_document
---



The goal of this script is to create graph objects that contain all the necessary information resulting in the manipulation of graphs performing most of the cleaning.

The hope is that this will make the processes and code more simple and easier to understand


#Contact details charging team
01926 654633 or email charging.enquires@nationalgrid.com

I should change the graph so all information is encoded into it as graph attributes.

##Node attributes
Generated power <- theoretcial generated max
power demand
balanced power
name

##Edge attributes
Y
Power Limit
Power FLow

With the information above held in the graph each node would contain all necessary information for the analysis and would simplify a lot of the processes

unrealistic rfesearch questions

done no work

Do a non-cascading montecarlo removal , compare with a cascading network.


#Setup Chunk

```{r}
setwd("/home/jonno/Create_ETYS_network/SubCode")
source("Setup.R")

```


#Load Tariff and Trasnport
 
```{r}
KeepPath <- getwd()

#Load Tariff aka generation data
setwd(Tariff)

GenerationData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =10, skip = 33) %>%
  setNames(make.names(names(.))) %>%
  mutate(Site = str_sub(Node.1,1,4))

LocalAssetData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =11, skip = 11) %>%
  setNames(make.names(names(.)))

TransportData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =12, skip = 11) %>%
  setNames(make.names(names(.)))

setwd(KeepPath)
rm(KeepPath)
```

#Clean and seperate Transport

```{r}
trans1 <-TransportData[,1:16] %>% 
  filter(!is.na(Bus.ID))

trans2 <- TransportData[,17:59] %>% 
  filter(!is.na(Bus.1)) %>%
  group_by(Bus.1, Bus.2) %>% #trying to stop the non-unique identifier problem
    mutate(Link = paste(Bus.1,Bus.2, 1:n(),sep = "-")) %>% #This allows multiple edges 
    #between the same node pair, it is not certain the data is always correct!
    ungroup %>%
  group_by(Bus.1, Bus.2) %>% #trying to stop the non-unique identifier problem
    mutate(Link = paste(Bus.1,Bus.2, 1:n(),sep = "-")) %>% #This allows multiple edges 
    #between the same node pair, it is not certain the data is always correct!
    ungroup  %>%
#set construct line limits really high
  mutate(Link.Type = tolower(Link.Type),
    Link.Limit = ifelse(Link.Type == "construct", 1e5, Link.Limit)) %>%
  #add in susceptance
  mutate(Y = 1/X..Peak.Security.) 
  
```



```{r}

VertexMetaData <- trans1 %>%
  select(Bus.Name, 
         Voltage, 
         Demand, 
         Generation = Generation.B.....Year.Round...Transport.Model., 
         BalencedPower = BusTransferB, 
         Bus.Order)

gbase <- trans2 %>%
  #this mutate is because the base limits cause a rolling blackout due to the below lines being overpowered
  # mutate(Link.Limit = case_when(
  #   Link == "BRAC20-BONB20-1" ~826,
  #   Link == "FAUG10-LAGG1Q-1" ~826,
  #   Link == "KEIT20-KINT20-1" ~500,
  #   Link == "LAGG1Q-MILW1S-1" ~826,
  #   TRUE ~ Link.Limit
  # )) %>%
  select(Bus.1, 
         Bus.2, 
         Y, 
         Link.Limit,
         Link) %>%
  mutate(PowerFlow = 0) %>%
  graph_from_data_frame(., directed=FALSE, vertices = VertexMetaData)

gbase <- set.vertex.attribute(gbase, "component", value = components(gbase)$membership)
gbase <- set.edge.attribute(gbase, "name", value = get.edge.attribute(gbase, "Link"))

```


create the edge voltage

This code block creates the line voltage attribute using the vertex meta data
```{r}

#If the voltage of the from node is equal to the voltage of the two node then the line voltage is also the same, otherwise the line is a transformer and the voltage is 0
EdgeVoltage <- ifelse(
  get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,1])== get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,2]), 
       get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,1]),
       0)

gbase <- set_edge_attr(gbase, "Voltage", value = EdgeVoltage)

```



```{r}


#Looking at the below code it seems that the 4 links that are overpowered when there is no tweaking of the line limits are still overpowered, the difference is that they don't cause a massive rolling blackout, but they do cause a small disturbance in the network. By this I think that the code was previously deleting the wrong lines causing major issues.
CascadeList <- Cascade(list(gbase))

vcount(CascadeList[[1]])
vcount(CascadeList[[2]])
vcount(CascadeList[[3]])

ecount(CascadeList[[1]])
ecount(CascadeList[[2]])
ecount(CascadeList[[3]])
sameedges <- (get.edge.attribute(CascadeList[[1]], "Link") %in% get.edge.attribute(CascadeList[[2]], "Link"))

get.edgelist(CascadeList[[1]])[!sameedges,]

setwd(basewd)
dir.create("test")
set.seed(129)
CreateCascadeGif(CascadeList, file.path(basewd,"test"), "testme")

       
setwd(basewd)
dir.create("test")
set.seed(129)
CreateCascadeGif(unlist(test,recursive=F), file.path(basewd,"test"), "testme")

setwd(basewd)
dir.create("testEdges")
set.seed(129)
CreateCascadeGif(unlist(testEdges,recursive=F), file.path(basewd,"testEdges"), "testme")

```

make a non-adaptive  strategy extractor
```{r}
g<- gbase

DeleteNodes <- RandomAttack(gbase, Target = "Nodes", Number = vcount(gbase))
DeleteEdges <-RandomAttack(gbase, Target = "Edges", Number = ecount(gbase))

FixedNodes <- quo(FixedStrategyAttack(g, DeleteNodes))
FixedEdges <- quo(FixedStrategyAttack(g, DeleteEdges, Target = "Edges"))

set.seed(15)
test <- list(gbase) %>%
  list %>%
  AttackTheGrid(., FixedNodes, MinMaxComp = 0.8)


set.seed(15)
test <- list(gbase) %>%
  list %>%
  AttackTheGrid(., FixedNodes, MinMaxComp = 0.8)

AdaptiveRandomEdgeAttack <- quo(RandomAttack(g, Target , Number))
AdaptiveStrat <- quo(AdaptiveStrategyAttack(g, AdaptiveRandomEdgeAttack))


AdaptiveRandomEdgeAttack <- quo(RandomAttack(g, Target, Number))
AdaptiveStrat <- quo(AdaptiveStrategyAttack(g, AdaptiveRandomEdgeAttack))

set.seed(15)
test <- list(gbase) %>%
  list %>%
  AttackTheGrid(., AdaptiveStrat, MinMaxComp = 0.8)


```


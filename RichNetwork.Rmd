---
title: "Graph based functions"
author: "Jonathan Bourne"
date: "11 September 2017"
output: html_document
---



The goal of this script is to create graph objects that contain all the necessary information resulting in the manipulation of graphs performing most of the cleaning.

The hope is that this will make the processes and code more simple and easier to understand


Get attack lists. check the extreme ends
re-order grid balancing

#some isreali dudes did something on the american grid
https://www.scientificamerican.com/article/us-electrical-grid-on-failure/

#Doctorate includes at least part on cyber attacks on grids
http://digitalcommons.uri.edu/cgi/viewcontent.cgi?article=1279&context=oa_diss

#Contact details charging team
01926 654633 or email charging.enquires@nationalgrid.com

I should change the graph so all information is encoded into it as graph attributes.


#next week

each node and each edge removed
re-do figures
small hand example
get extreme node list - can save and dump files
simple starter explnation





#Setup Chunk

```{r}
setwd("/home/jonno/Create_ETYS_network/SubCode")
source("Setup.R")

```


#Load Tariff and Trasnport
 
```{r}
KeepPath <- getwd()

#Load Tariff aka generation data
setwd(Tariff)

GenerationData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =10, skip = 33) %>%
  setNames(make.names(names(.))) %>%
  mutate(Site = str_sub(Node.1,1,4))

LocalAssetData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =11, skip = 11) %>%
  setNames(make.names(names(.)))

TransportData <- read_excel("Tariff & Transport Model_2018_19 Tariffs_External.xlsm", sheet =12, skip = 11) %>%
  setNames(make.names(names(.)))

setwd(KeepPath)
rm(KeepPath)
```

#Clean and seperate Transport

```{r}
trans1 <-TransportData[,1:16] %>% 
  filter(!is.na(Bus.ID))

trans2 <- TransportData[,17:59] %>% 
  filter(!is.na(Bus.1)) %>%
  group_by(Bus.1, Bus.2) %>% #trying to stop the non-unique identifier problem
    mutate(Link = paste(Bus.1,Bus.2, 1:n(),sep = "-")) %>% #This allows multiple edges 
    #between the same node pair, it is not certain the data is always correct!
    ungroup %>%
  group_by(Bus.1, Bus.2) %>% #trying to stop the non-unique identifier problem
    mutate(Link = paste(Bus.1,Bus.2, 1:n(),sep = "-")) %>% #This allows multiple edges 
    #between the same node pair, it is not certain the data is always correct!
    ungroup  %>%
#set construct line limits really high
  mutate(Link.Type = tolower(Link.Type),
    Link.Limit = ifelse(Link.Type == "construct", 1e5, Link.Limit)) %>%
  #add in susceptance
  mutate(Y = 1/X..Peak.Security.) 
  
```



```{r}

VertexMetaData <- trans1 %>%
  select(Bus.Name, 
         Voltage, 
         Demand, 
         Generation = Generation.B.....Year.Round...Transport.Model., 
         BalencedPower = BusTransferB, 
         Bus.Order)

gbase <- trans2 %>%
  #this mutate is because the base limits cause a rolling blackout due to the below lines being overpowered
  # mutate(Link.Limit = case_when(
  #   Link == "BRAC20-BONB20-1" ~826,
  #   Link == "FAUG10-LAGG1Q-1" ~826,
  #   Link == "KEIT20-KINT20-1" ~500,
  #   Link == "LAGG1Q-MILW1S-1" ~826,
  #   TRUE ~ Link.Limit
  # )) %>%
  select(Bus.1, 
         Bus.2, 
         Y, 
         Link.Limit,
         Link) %>%
  mutate(PowerFlow = 0) %>%
  graph_from_data_frame(., directed=FALSE, vertices = VertexMetaData)

gbase <- set.vertex.attribute(gbase, "component", value = components(gbase)$membership)
gbase <- set.edge.attribute(gbase, "name", value = get.edge.attribute(gbase, "Link"))

```


create the edge voltage

This code block creates the line voltage attribute using the vertex meta data
```{r}

#If the voltage of the from node is equal to the voltage of the two node then the line voltage is also the same, otherwise the line is a transformer and the voltage is 0
EdgeVoltage <- ifelse(
  get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,1])== get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,2]), 
       get.vertex.attribute(gbase, "Voltage", get.edgelist(gbase)[,1]),
       0)

gbase <- set_edge_attr(gbase, "Voltage", value = EdgeVoltage)

```


#produce subgraph k jumps away from named node
```{r}

KNearestNodes(gbase, "ALVE4A", 2) %>% induced_subgraph(gbase, .) %>% plot

```



```{r}


#Looking at the below code it seems that the 4 links that are overpowered when there is no tweaking of the line limits are still overpowered, the difference is that they don't cause a massive rolling blackout, but they do cause a small disturbance in the network. By this I think that the code was previously deleting the wrong lines causing major issues.
CascadeList <- Cascade(list(gbase))

vcount(CascadeList[[1]])
vcount(CascadeList[[2]])
vcount(CascadeList[[3]])

ecount(CascadeList[[1]])
ecount(CascadeList[[2]])
ecount(CascadeList[[3]])
sameedges <- (get.edge.attribute(CascadeList[[1]], "Link") %in% get.edge.attribute(CascadeList[[2]], "Link"))

get.edgelist(CascadeList[[1]])[!sameedges,]

setwd(basewd)
dir.create("test")
set.seed(129)
CreateCascadeGif(CascadeList, file.path(basewd,"test"), "testme")



```

make a non-adaptive  strategy extractor
```{r}
g<- gbase

DeleteNodes <- RandomAttack(gbase, Target = "Nodes", Number = vcount(gbase))
DeleteEdges <-RandomAttack(gbase, Target = "Edges", Number = ecount(gbase))

FixedNodes <- quo(FixedStrategyAttack(g, DeleteNodes))
FixedEdges <- quo(FixedStrategyAttack(g, DeleteEdges, Target = "Edges"))

set.seed(15)
testattack <- AttackTheGrid(list(list(gbase)), FixedNodes, MinMaxComp = 0, TotalAttackRounds = 200, CascadeMode = TRUE) 


set.seed(15)
test <- list(gbase) %>%
  list %>%
  AttackTheGrid(., FixedNodes, MinMaxComp = 0.8)

AdaptiveRandomEdgeAttack <- quo(RandomAttack(g, Target , Number))
AdaptiveStrat <- quo(AdaptiveStrategyAttack(g, AdaptiveRandomEdgeAttack))


AdaptiveRandomEdgeAttack <- quo(RandomAttack(g, Target, Number))
AdaptiveStrat <- quo(AdaptiveStrategyAttack(g, AdaptiveRandomEdgeAttack))

set.seed(15)
test <- list(gbase) %>%
  list %>%
  AttackTheGrid(., AdaptiveStrat, MinMaxComp = 0.8)


 test <- microbenchmark(suppressMessages(AttackTheGrid(list(list(gbase)), FixedNodes, MinMaxComp = 0.005, StopPoint = c(170, 440)[1], CascadeMode =  c(TRUE,FALSE)[1])), times = 1)

```


#test non cascadeing grid demolition

I think that dead islands are a major cause of grid collapse.

```{r}

set.seed(123)

Nodesims <- c(TRUE, FALSE) %>% map_df(~{ 
  MonteCarloAttack(gbase, 
                         simulations = 10,
                         AttackStrategy = RandomAttack,
                         Type = "Fixed",
                         MinMaxComp = 0.0, 
                         TotalAttackRounds = 30,
                         Target = "Edges",
                         CascadeMode = .x) %>%
  mutate(Cascade = .x)
}
)

setwd(basewd)
saveRDS(Nodesims, "100simulationsRandomAttackto30Nodes.rds")
#Nodesims <- readRDS( "100simulationsRandomAttackto0005or440.rds" )

quo(mean(UQS(list(x = 1:4)))) %>% eval_tidy

SummaryofGC <- Nodesims %>% 
  SummariseMonteCarlo

SummaryofGC %>%
  #filter(ID<50) %>%
ggplot(aes(x= ID, y = mean, colour = Cascade)) +geom_line() +
    geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = Cascade), alpha = 0.3)+
  labs(title = "Largest componant as a % of Original Giant Component\n under different removal regimes" , x = "Number of nodes removed from Grid", y = "Largest component as a % GC")


SummaryofGC %>%
  #  filter(ID<50) %>%
ggplot(aes(x= ID, y = mPGfract, colour = Cascade)) +geom_line() +
      geom_ribbon(aes(ymin=PG05, ymax=PG95, fill = Cascade), alpha = 0.3)+
      labs(title = "Percentage of demand that the grid can meet in current state" , x = "Number of nodes removed from Grid", y = "Total generating capacity as % of demand")

```


#Edge collapse

Need to talk about what is being removed etc where does balance gen go?

```{r}
gc()
set.seed(1234)
Edgesims <- 1:2 %>%  map_df(~{
  
Bigdf <- data.frame(Nodes = NULL, GCfract = NULL, Simulation = NULL)

for(n in 1:100){
  
  #These need to be double assigned so that they are assigned outside the map function. Otherwise only the values in the global environment are used... I don't know why.
  DeleteNodes <<- RandomAttack(gbase, Target = "Edges", Number = ecount(gbase))
  FixedNodes <<- quo(FixedStrategyAttack(g, DeleteNodes, Target = "Edges"))
  
  sim <- paste0("Simulation_", n)
  print(sim)

  GridList <- suppressMessages(AttackTheGrid(list(list(gbase)), 
                                             FixedNodes, 
                                             MinMaxComp = 0.0, #
                                             TotalAttackRounds = 30, 
                                             CascadeMode =  c(TRUE,FALSE)[.x])) %>%
   ExtractNetworkStats(.) %>%
  mutate( Simulation = n)
  #To try and prevent crashing
  gc()
  
  Bigdf <- bind_rows(Bigdf, GridList) %>%
    mutate(Cascade = c(TRUE,FALSE)[.x])
}

return(Bigdf)
}
)



SummaryofGCEdge <-  %>% 
  SummariseMonteCarlo


setwd(basewd)
saveRDS(Edgesims,"100simulationsRandomAttackto30Edges.rds")


SummaryofGCEdge %>%
  filter(ID<150) %>%
ggplot(aes(x= ID, y = mean, colour = Cascade)) +geom_line() +
    geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = Cascade), alpha = 0.3)+
  labs(title = "Largest componant as a % of Original Giant Component\n under different removal regimes" , x = "Number of nodes removed from Grid", y = "Largest component as a % GC")


SummaryofGCEdge %>%
ggplot(aes(x= ID, y = mPGfract, colour = Cascade)) +geom_line() +
      geom_ribbon(aes(ymin=PG05, ymax=PG95, fill = Cascade), alpha = 0.3)+
      labs(title = "Percentage of demand that the grid can meet in current state" , x = "Number of nodes removed from Grid", y = "Total generating capacity as % of demand")

```


```{r}

testgraph <- KNearestNodes(gbase, "ALVE4A", 2) %>% induced_subgraph(gbase, .)

  DeleteNodes <- RandomAttack(testgraph,Target = "Edges",Number = ecount(testgraph))
  FixedNodes <- quo(FixedStrategyAttack(g, DeleteNodes, Target = "Edges"))

Output <- AttackTheGrid(list(list(testgraph)), 
                                             FixedNodes, 
                                             MinMaxComp = 0, #
                                             TotalAttackRounds = 10, 
                                             CascadeMode =  TRUE)

 CreateCascadeGif(unlist(Output, recursive = F))
 

```


---
title: "Graph based functions"
author: "Jonathan Bourne"
date: "11 September 2017"
output: html_document
---

Just under 20 node attacks an hour

The goal of this script is to create graph objects that contain all the necessary information resulting in the manipulation of graphs performing most of the cleaning.

The hope is that this will make the processes and code more simple and easier to understand


Get attack lists. check the extreme ends
re-order grid balancing

#some isreali dudes did something on the american grid
https://www.scientificamerican.com/article/us-electrical-grid-on-failure/

#Doctorate includes at least part on cyber attacks on grids
http://digitalcommons.uri.edu/cgi/viewcontent.cgi?article=1279&context=oa_diss

#Contact details charging team
01926 654633 or email charging.enquires@nationalgrid.com

I should change the graph so all information is encoded into it as graph attributes.


A stress metric or loading metric, that gives some sort of measure of how close the network is to having black outs would be really useful, that would help identify nodes that increase stress but don't actually cause any blackouts themselves. Preperation nodes

#next week

each node and each edge removed
re-do figures
get extreme node list - can save and dump files

small hand example
simple starter explnation





#Setup Chunk

```{r}
setwd("/home/jonno/Create_ETYS_network/SubCode")
source("Setup.R")

source("LoadData2.R")


```

#produce subgraph k jumps away from named node
```{r}

KNearestNodes(gbase, "TAUN4A", 2) %>% induced_subgraph(gbase, .) %>% plot

#Connector nodes can produce the maximum power allowed by the power limit of thier connecting lines
Southwest <- str_split("EXET40 ALVE4B ALVE4A TAUN4A TAUN4B ABHA4B ABHA4A LAGA40 LAND4A LAND4B INDQ40", pattern = " ", simplify = T) 

Southwestg <- CreateSubgraph(gbase, Southwest[8:11] )

get.vertex.attribute(Southwestg)
Southwestg %>% plot


SlackRef <-"LAND4A"# "EXET40"
AZero <- CreateTransmission(Southwestg, "Link")
A <- AZero[,colnames(AZero)!=SlackRef, drop = FALSE]
C <- LinePropertiesMatrix(Southwestg)

B <- t(A) %*% C %*% A
  
InjectionVector <- get.vertex.attribute(Southwestg, "BalencedPower")[get.vertex.attribute(Southwestg, "name")!=SlackRef]

Power <- C %*% A %*% solve(B, InjectionVector)

```


make a non-adaptive  strategy extractor
```{r}
set.seed(15)
DeleteNodes <- RandomAttack(gbase, Target = "Nodes", Number = vcount(gbase))
DeleteEdges <-RandomAttack(gbase, Target = "Edges", Number = ecount(gbase))

FixedNodes <- quo(FixedStrategyAttack(g, DeleteNodes))
FixedEdges <- quo(FixedStrategyAttack(g, DeleteEdges, Target = "Edges"))


testattack <- AttackTheGrid(list(list(gbase)), FixedNodes, MinMaxComp = 0, TotalAttackRounds = 10, CascadeMode = FALSE) 


#extract the number of nodes in the last of each list, precursor to finding the deleted node
NodesTargeted(testattack)

```


#delete each node see what happens

This code cycles throug all nodes and edges and measures the effect of the GCfract and PowerGen for a single outage.

```{r}
EdgeNodeDeleteion <- c("Nodes", "Edges") %>% map_df(~{

  Target = .x
  Number <- ifelse(Target == "Nodes", vcount(gbase), ecount(gbase))
  
    DeleteNodes <- RandomAttack(gbase, Target = Target, Number = Number)
    Out <- DeleteNodes %>% 
      map2_df(.x = ., .y = Target, ~{
      
       DeleteNodes <- .x
       #FixedNodes <- quo(FixedStrategyAttack(g, DeleteNodes))
      
       FixedNodes <- quo(FixedStrategyAttack(g, DeleteNodes, UQS(list(Target = .y))))
       
       AttackTheGrid(list(list(gbase)), 
                     FixedNodes, 
                     MinMaxComp = 0, 
                     TotalAttackRounds = 1, 
                     CascadeMode = TRUE) %>% 
        ExtractNetworkStats(.) %>%
        mutate(Deleted = .x,
               Type = .y)
        
      }
    )

  }
)

```


#test non cascadeing grid demolition

I think that dead islands are a major cause of grid collapse.

```{r}

input <- c(TRUE,FALSE)

  Nodesims <- input %>% map(~{ 
    MonteCarloAttack(gbase, 
                           simulations = 100,
                           AttackStrategy = RandomAttack,
                           Type = "Fixed",
                           MinMaxComp = 0.0, 
                           TotalAttackRounds = 30,
                           Target = "Nodes",
                           CascadeMode = .x,
                           cores = 7)
    

    }
   ) %>% set_names(paste0("v.", input))

setwd(basewd)
saveRDS(Nodesims, "100simulationsRandomAttackto30Nodes.rds")
#Nodesims <- readRDS( "100simulationsRandomAttackto0005or440.rds" )

SummaryofGC <- Nodesims %>%
    modify_depth(., 1, keep, is.data.frame ) %>%
  flatten %>%
  bind_rows() %>% 
  SummariseMonteCarlo

SummaryofGC %>%
  #filter(ID<50) %>%
ggplot(aes(x= ID, y = mean, colour = Cascade)) +geom_line() +
    geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = Cascade), alpha = 0.3)+
  labs(title = "Largest componant as a % of Original Giant Component\n under different removal regimes" , x = "Number of nodes removed from Grid", y = "Largest component as a % GC")


SummaryofGC %>%
  #  filter(ID<50) %>%set.vertex.attribute(., "OldDegree", value = degree(.))
ggplot(aes(x= ID, y = mPGfract, colour = Cascade)) +geom_line() +
      geom_ribbon(aes(ymin=PG05, ymax=PG95, fill = Cascade), alpha = 0.3)+
      labs(title = "Percentage of demand that the grid can meet in current state" , x = "Number of nodes removed from Grid", y = "Total generating capacity as % of demand")

```


#Edge collapse

Need to talk about what is being removed etc where does balance gen go?

```{r}
gc()
set.seed(1234)
Edgesims <- 1:2 %>%  map_df(~{
  
Bigdf <- data.frame(Nodes = NULL, GCfract = NULL, Simulation = NULL)

for(n in 1:100){
  
  #These need to be double assigned so that they are assigned outside the map function. Otherwise only the values in the global environment are used... I don't know why.
  DeleteNodes <<- RandomAttack(gbase, Target = "Edges", Number = ecount(gbase))
  FixedNodes <<- quo(FixedStrategyAttack(g, DeleteNodes, Target = "Edges"))
  
  sim <- paste0("Simulation_", n)
  print(sim)

  GridList <- suppressMessages(AttackTheGrid(list(list(gbase)), 
                                             FixedNodes, 
                                             MinMaxComp = 0.0, #
                                             TotalAttackRounds = 30, 
                                             CascadeMode =  c(TRUE,FALSE)[.x])) %>%
   ExtractNetworkStats(.) %>%
  mutate( Simulation = n)
  #To try and prevent crashing
  gc()
  
  Bigdf <- bind_rows(Bigdf, GridList) %>%
    mutate(Cascade = c(TRUE,FALSE)[.x])
}

return(Bigdf)
}
)



SummaryofGCEdge <-  %>% 
  SummariseMonteCarlo


setwd(basewd)
saveRDS(Edgesims,"100simulationsRandomAttackto30Edges.rds")


SummaryofGCEdge %>%
  filter(ID<150) %>%
ggplot(aes(x= ID, y = mean, colour = Cascade)) +geom_line() +
    geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = Cascade), alpha = 0.3)+
  labs(title = "Largest componant as a % of Original Giant Component\n under different removal regimes" , x = "Number of nodes removed from Grid", y = "Largest component as a % GC")


SummaryofGCEdge %>%
ggplot(aes(x= ID, y = mPGfract, colour = Cascade)) +geom_line() +
      geom_ribbon(aes(ymin=PG05, ymax=PG95, fill = Cascade), alpha = 0.3)+
      labs(title = "Percentage of demand that the grid can meet in current state" , x = "Number of nodes removed from Grid", y = "Total generating capacity as % of demand")

```


#Analysing worst collapse

```{r}
input <- c(FALSE)

  Analysims <- input %>% map(~{ 
    MonteCarloAttack(gbase, 
                           simulations = 20,
                           AttackStrategy = RandomAttack,
                           Type = "Fixed",
                           MinMaxComp = 0.0, 
                           TotalAttackRounds = 10,
                           Target = "Nodes",
                           CascadeMode = .x,
                     cores = 1)
    

    }
   ) %>% set_names(paste0("v.", input))
  
CollapseRank <- BiggestCollapse(Analysims$v.FALSE$NetData, PowerGen)

FixedNodes <- quo(FixedStrategyAttack(g, Analysims$v.FALSE$AttackedNodes[[5]]))

CheckCollapse <- AttackTheGrid(list(list(gbase)), FixedNodes, MinMaxComp = 0, TotalAttackRounds = 30, CascadeMode = FALSE) 

#not sure what to check now but there are two components and about 44 nodes have been lost
CheckCollapse[[31]][[1]] %>% components()

#perhaps making a gif would help understand what has happened?


```


```{r}

testgraph <- KNearestNodes(gbase, "ALVE4A", 2) %>% induced_subgraph(gbase, .)

  DeleteNodes <- RandomAttack(testgraph,Target = "Edges",Number = ecount(testgraph))
  FixedNodes <- quo(FixedStrategyAttack(g, DeleteNodes, Target = "Edges"))

Output <- AttackTheGrid(list(list(testgraph)), 
                                             FixedNodes, 
                                             MinMaxComp = 0, #
                                             TotalAttackRounds = 10, 
                                             CascadeMode =  TRUE)

 CreateCascadeGif(unlist(Output, recursive = F))
 

```

